Basic syntax
Data types
Variables
Operators
Control flow (if statements, loops)
Arrays
Functions and methods
Classes and objects
Inheritance
Polymorphism
Encapsulation
Interfaces
Exception handling
File I/O
Delegates and events
Generics
LINQ (Language Integrated Query)
Asynchronous programming
Collections (List, Dictionary, etc.)
Attributes and Reflection
Nullable types
Properties
Indexers
Namespaces
Dependency Injection
Unit testing (e.g., using NUnit)
Working with databases (ADO.NET, Entity Framework)
ASP.NET for web development (optional)
WPF or WinForms for desktop applications (optional)
WCF or Web API for building services (optional)

--------------------------------------------------[Create Console Project] --------------------------------------------------
	- Bash => dotnet new console 	// [console, mvc, webapi, ...] [-o output, -n name, ...]
	- Bash => dotnet sln add "path to project"
	- Bash => dotnet add package Microsoft.EntityFrameworkCore
	- bash => dotnet run			// to run the project
	- bash => dotnet build          // build the application
	- bash => dotnet restore 		// install the necessary  
	
[Comments]
	- //							// Single Line Comment	
	- /* */                         // Multiple Line Comment
	- ///							// XML Comment 
	
-------------------------------------------------- [Data Tpyes] --------------------------------------------------
	
	- [ Integral Types ]
		- byte  / sbyte	=> 8bit			
		- short / ushort	=> 16bit		=> System.Int16	//.Net Type
		- int   / uint	=> 32bit  	=> System.Int32     //.NET Type
		- long  / ulong	=> 64bit		=> System.Int64	//.NET Type
		
	- [ Floating-Point ]
		- float 		=> 32bit		0.1f		=> System.Single			
		- double 		=> 64bit		0.1		=> System.Double
		- decimal 	=> 128bit		0.1m		=> System.Decimal
		
	- [ Character ]
		- Char 		=> 16bit		=> System.Char
		
	- [ String ]
		- String 		=> 16bit/char	=> System.String
	
	- [ Boolean ]
		- bool		=> 1bit		=> true/false	=> System.Boolean
				
	- [ Date ]		
		- DateTime			=> 8bit							=> System.DateTime
		- DateTime date = DateTime.now;
		
	- [ Object ]
		- var person = new { name = "John", age = 25 };		// Anonymous types
		- Person person = new Person("john", 25);		// Instance from a Class Person
		- dynamic obj = new System.Dynamic.ExpanoObject();	obj.name = "John"; Console.WriteLine(obj.name);	// Dynamic Object
	
	- [ Nullable ]
		- [primitive] + [?]	=> allow null

	- [ Enumerations ]
		- enum 					=> value type that defines a set of named integral constants
		- enum Days {sat, sun, mon = 5, tues, }		// int x = (int)Days.sun;
		
	- [ Arrays ]
		- int[] data = {2,3,5} | new int[] {2,3,5} | new int[3] {2,3,5}
		
	- [ Structs ]
		- public struct Person { 
			public string name;
			public int age;   									                       
			public Person(){this.name = "John"; this.age = 25;}					// Constructor
			public void DisplayInfo(){ Conole.Writeline($"{name} {age}") }		// Methods
		}
	
	- [ Classes ] 	--------------------------------------------------
		- Members:		Fields, Methods, Properties(get, set), Constructor
		- Constructor: 	[ Default, Parameterized, DeepCopy, ShallowCopy, Static]
		- [ Parent Class(base) | Child Class(derived) | Abstract Class | Sealed Class | Static Class | Partial Class | Generic Class | Container Class ]
		- [ Singleton Class | Factory Class | Immutable Class | DTO Class | Attribute Class | Disposal Class |   ]
		
	- [ Interfaces ] 	--------------------------------------------------
		- public interface IMovable{ void Draw(); int X {get; set;} }
	
	- [ Other Types ]
		- dynamic 			=> Represents an object whose operations are resolved at runtime
		- var				=> Implicitly-typed variable, the type is inferred by the compiler
		
-------------------------------------------------- [ Operators ] --------------------------------------------------

	- Arithmetic Operators: 		=> [+, -, /, *, %]  
	
	- Comparison Operators: 		=> [==, !=, <, >, <=, >=]   
	
	- Logical Operators: 			=> [&&, ||, !]              
	
	- Assignment Operators: 		=> [=, +=, -=, *=, /=, %=]  
	
	- Inc and Dec Operators: 		=> [++, --]  
	
	- Bitwise Operators: 		=> [&, |, ^, ~, <<, >>]
		
-------------------------------------------------- [ Implicit / Explicit Conversions ] --------------------------------------------------
	- Implicit Conversion is done by the compiler if there is no data will be lost like:
		int x = 5;	double y = x;			// here x implicitly converted into double => no data loss
		
	- Explicit Conversion is done manually and need a cast to force it like:
		double x = 3.3; 	int y = (int)x;		// We have to cast the value as an int
		
-------------------------------------------------- [Built-In Methods] --------------------------------------------------

	- [String Class Methods]
		- .Length | [indexing] | .Substring() | .Concat | .Equals | .Compare | .ToLower
		  .ToUpper | .Trim | .Contains | .IndexOf | .LastIndexOf | .Replace | .Split
	
	- [Math Class Methods]
		- Math.[Add, Subtact, Multiply, Divide, Pow, Sin, Cos, Tan, PI, Log, Log10, Sqrt, Round, Ceiling, Floor, Abs]
	
	- [Array Methods]
		- .Length | [Indexing] | .CopyTo | .Clone | .Sort | .BinarySearch | .Fill | .Reverse | .Clear | .Equals | .ToList() | .Copy
		- int[,] matrix;
		- int[][] jaggedArray;
	
	- [Type Conversion Methods]
		- implicit / explicit (casting)
		- Convert.ToInt[16/32/64] | .ToString | int.Parse | int.TryParse 
		- [Boxing & UnBoxing]
			- [Boxing] 
				- ValueType 			=> 	ReferenceType
				- int intvalue = 42;		object BoxedValue = intvalue;
				
			- [Unboxing]
				- ReferenceType			=> 	ValueType
				- object BoxedValue = 42;   int intValue = (int)BoxedValue;
			
			- [Performance Considerations]
				- (memory allocation) new object is created in the heap and the reference to that object stored in the stack
				- (Copying) Copy the value type from the stack, which introduces overhead especially for larger value types
				- (Type-Checking Overhead) when unboxing a value from an object there's a need for type-checking to ensure that the object actually contains a value of the expected type
				
		- [explicit operator]
			- public static explicit operator double(myObject value){ return value.weight; }
			// User-defined explicit conversion operator which convert an instance from a class to a double
			
	- [Linq Methods]
		- Where | Select | OrderBy | OrderByDescending | GroupBy | Join | GroupJoin | Take | Skip
		- First | FirstOrDefault | Single | SingleOrDefault | Last | LastOrDefault | Any | All | Aggregate
		- Count | Sum | Min | Max | Average | Concat | Distinct | Union | Intersect | Except | AsQueryable
		- Reverse | AsEnumerable | ToArray | ToList | ToDictionary | OfType | Cast | ToLookup | Skip | Take 
	
	- [IO Methods] (using System.IO;)
		
		- [File Class]
			- File.ReadAllText("") 			=> Returns string
			- FileInfo("")					=> Returns FileInfo 
			- File.[Exists | Copy | Delete | Move | ReadAllLines | ReadAllBytes | WriteAllText | AppendTet | OpenRead | OpenWrite]
		
		- [Directory Class]
			- Directory.GetFiles("") 		=> Returns string[]
			- DirectoryInfo("")				=> Returns DirectoryInfo
			- Directory.[Exists | CreateDirectory | GetFiles | GetDirectories | GetParent | Move | Delete | GetLogicaldrives | GetCreationTime | GetLastAccessTime | GetLastWriteTime]
		
		- [Path Class]
			- Path.[Combine() | GetExtension | GetFileName | GetDirectoryName | GetFullPath | GetPathRoot | GetRandomFileName | IsPathRooted | ChangeExtension | GetTempFileName | GetTempPath ]
			
		- [FileStream Class]
			- FileStream fs = new FileStream("",FileMode.Open)	
			- fs.[Read | Write | Seek | Length | Flush | Close | Dispose | CanRead | CanWrite | CanSeek | Position ]
		
	- [Miscellaneous]
		
		- [Random Class]
			- Random random = new Random()
			- random.[ Next | NextDouble | NextByte(new byte[10]) | Convert.ToBase64String(new byte[10]) => string ]
			
		- [Convert Class]
			- Convert.[ ToBoolean | ToByte | ToInt32 | ToSingle | ToDouble | ToString | ToDateTime | ToChar | ChangeType ]
		
		- [DateTime & TimeSpan Classes]
			- DateTime.[Now | Today | UtcNow | Parse | TryParse | TopString("yyyy-MM-dd HH:mm:ss") | AddDays | Now.Subtract | Compare | Now.DayOfWeek | IsLeapYear ]
			- TimeSpan.[FromSeconds | FromMInutes | FromHours | Parse(time) | Compare |  ]
			- time.[Add | Subtract | TotalSeconds | TotalHours | TotalMinutes | ToString() | Equals(time2) | Zero ]

		- [Console Class]
			- Console.[Write | WriteLine | Read | Readline | ReadKey | Beep | Title | WindowWidth | WindowHeight | BufferWidth | BufferHeight ]
		
		- [Environment Class]
			- Environment.[GetCommandLineArgs | CurrentDirectoruy | Exit | GetFolderPath | MachineName | OSVersion | StackTrace | SystemDirectory | TickCount | TickCount64 | UserDomainName | userName | Version | WorkingSet]
		
--------------------------------------------------  [WorkFlow] --------------------------------------------------
	- [Sequential Execution]
		- Statements are executed one after the other in the order they appear in the code 
		
	- [Selection Statements]
		- if - else
		- switch
	
	- [Repetition Statements]
		- for		=> Number of Iteration is knew
		- wihle		=> Unknown number of iteration and continues looping until the condition change
		- do-while	=> Same as while but to ensure that the body executed at least once
		- foreach-in	=> Looping over Collections like Arrays, Lists, etc...
	
	- [Jump Statements]
		- break
		- continue
		- return
		- goto
		
	- [Exception Handling]
		- try-catch-finally
		- try{}catch(){}catch(){}finally{}
		- Use cases for finally [Cleanup Operations | Guaranteed Execution | Resource Deallocation]


	- [Functions & Methods]
		- Function is a self-contained unit of code that performs a specific task
			[AccessModifier] [ReturnType] [FunctionName]([Params]){[body]}
		- Method is a function but associated with an object or a class (a member of a class)
		- Arrow function like: public ind Add(int a, int b) => a + b;
		
-------------------------------------------------- [ Collections ] --------------------------------------------------

	- There are three types of collections pfovided by the .NET Framework
		- Collection (non-generic)
			- These are the older collection classes that existed before the introduction of generics in C# 2.0.
			- Less type-safe and less efficient than their generic counterparts
			- Like Queue, Stack, HashTable, ArrayList
			
		- Generic Collection
			- Introduced with C# 2.0, type-safe, more efficient, better performance due to elemination of boxing/unboxing, preferred to use in modern C# development
			- like List<T>, Dictionary<T>, Tvalue<T>, Queue<T>, Stack<T>
		
		- Concurent Collection
			- Itroduced in C# 4.0, designed for thread safety
			- Suitable for concurent operation in multithreaded scenarios
			- like ConcurrentQueue<T>, ConcurrentStack<T>, ConcurrentBag<T>, ConcurrentDictionary<TKey, TValue>
		
	
	Dictionary<TKey, TValue>: 	=> A collection of unique key-value pairs with fast access based on keys.
	List<T>: 			=> A dynamic array implementation for creating resizable lists.
	Queue<T>: 		=> Represents a first-in, first-out (FIFO) collection of objects.
	SortedList<TKey, TValue>: 	=> A collection of key-value pairs automatically sorted by keys.
	Stack<T>: 		=> Represents a last-in, first-out (LIFO) collection of objects.
	HashSet<T>: 		=> An unordered collection of unique elements with high-performance set operations.
	LinkedList<T>:		=> Represents a doubly-linked list for efficient insertion and removal.
		
	

 -------------------------------------------------- [ Access Modifier ] --------------------------------------------------
 
	- [ public ]			=>  	Visible over the entire solution.
	- [ private ]			=>   	Limited to the class scope.
	- [ internal ]			=>  	Visible only inside the project (namespace or assembly).
	- [ protected ]			=>  	Limited to children (derived classes) within the solution.
	- [ proteced internal ]		=>  	project scope + children scope in solution
	- [ private protected ]		=>  	Limited to children within the same assembly.

 -------------------------------------------------- [ Classes ] --------------------------------------------------

	- Blueprint or a template for creating objects
	
	- Members [ Fields(Attributes/Variables) | Properties | Methods | Constructors ]
	
	- Constructors [ Default, Parameterized, DeepCopy, ShallowCopy, Static ]
	
	- Property Accessor: [ get | set ]
	
	- [ Class Inheritance ]
		- Class can inherit only from a anothe single class and multiple Interfaces
		- class Dog : Animal, IMovable, ITouchable
		
	- [ Class Types ]
		
		- Abstract Class		=> cannot be instantiated. Could only inherit from it, become (parent) only
		- Sealed Class		=> can be instantiated but can't be inherited, become (child) only 	
		- Static Class		=> can't be instantiated also Contain only static members like Math class(Implicitly Sealed) 
		- Partial Class               => is defined in multiple files 
		- Generic Class		=> can with any datatype
		- Container Class		=> holds and manages a collection of other objects, encapsulating their functionality
		- Singleton Class		=> ensures only one instance is created and provides a global point of access to it
		- Factory Class		=> responsible for creating and returning instances of other classes
		- Immutable Class		=> whose instances can't be modified, enhancing predictibility and thread safety
		- DTO Class		=> used for transferring data between software application subsystems and distributed systems
		- Attribute Class		=> defines custom metadata and can be attached to code elements 
		- Disposal Class		=> implementing the IDisposable interface used for releasing unmanaged resources such as file handles or database connections
		- Concrete Class		=> Can create objects, have a complemete Implementation for all methods declared(non abstract method[ready to create objects])	
		
		---------------------------------------------------
		| Class Type        | Parent 	| Child 	| Object| |
		---------------------------------------------------
		| Static Class    	| No    	| No      | No      |
		| Abstract Class  	| Yes   	| Yes     | No      |
		
		| Sealed Class    	| No    	| Yes     | Yes     |
		| Attribute Class	| Yes   	| Yes     | No      |
		| Singleton Class 	| Yes   	| No      | Yes     |
		---------------------------------------------------
		
-------------------------------------------------- [ Classes Relations ] --------------------------------------------------

	- [Inheritance]
		- class inherit properties and members from another class and become derived(child) from the base(parent)
	- [Composition]
		- Involve Creating an instance of one class within another, The outer class depend on the inner class
	- [Agregation]
		- a special form of association where one Class contain another class inside it but not depend on it 
	- [Association]
		- bi-directional relationship, one-to-one, one-to-many, many-to-many
	- [Dependency]
		- a weaker form of accociation, occurs when a class relies on another class TEMPORARILY
	
-------------------------------------------------- [ Interfaces ] --------------------------------------------------
	
	- public interface IDrawable{ void method();  int id{get;set;} }
	- Contains Properties and Methods without body;
	- avoid overloading, to avoid ambiguity and implement SOLID ISP(interface segregation Principle)
	- use default value instead of overloads => void Method(int id, string name = "N/A") here name is optional because it have a default value
	- if there are multiple logical variations of a method, consider creating separate interface for each variation
	
	- [Methods] 	=> Implement Methods without providing an implementation(no body)
	- [Properties]	=> Declare a contract for a getter, setter, or both
	- [Events]	=> Declare a contract for subscribing and unsubscribing to an event
	- [Indexers]	=> Declare Indexers
	- [Nested Types]	=> Can Contain other types including nested interfaces or classes
	- [Default Interface Member (C#8.0 or later)]	=> Provide a way to include method implementations in interfaces, Classes can choose to use the default implementation or provide their own 
	- [Static Members (C#8.0 or later)]		=> Can include static members, these members are associated with the interface itsefl and not with any specific instance, only belongs to the interface
	

-------------------------------------------------- [ Built-In Interfaces ] --------------------------------------------------

	- [IEnumberable]		=> Represents a collection that can be enumerated (iterated) using 'foreach' loop
	- [IEnumerator]		=> Provides a way to iterate through a collection
		- Used to make the collections Enumerable by Implementing the interfaces IEnumerable and IEnumerator
		- IEnumerable Provide a way to iterate over any list  
	
	
	- [IComparable] 		=> Defines a method to compare an object with another of the same type
		- Choose the way you want to compare between two objects like compare objects by their Ids or names
		- Within the same class unlike IComparer 
	- [IComparer]		=> Defines a method to compare two objects of the specified type 
		- Used to choose the way to compare between class instances but in seperated class
		- The difference between IComparable  & IComparer is that IComparer provide a seperate class for comparison
	
	- [IEnumerable<T>]  	=> Represents a strongly typed collection that can be enumerated.
		- In Deferred execution, it filter the data in the client side after retreiving the data
		
	- [IEnumerator<T>]  	=> Provides a way to iterate through a strongly typed collection.
	
	- [IQueryable]  		=> Provides functionality to evaluate queries against a specific data source.
		- In Deferred execution it filter the data in the server side before getting the data
		- Is an interface defined in System.Linq, it's part of the language integrated query (LINQ)
		- Extends IEnumerable
			- able to build and execute more complex queries that can be translated into a form that is understood by the underlying data source
			- Allow deffered execution, with IEnumerable the entire dataset is loaded into memory before any filtering or projection is applied
			- On the other hand IQueryable allos the query to be composed and transformed into a format that is optimized for specific data source
			- The query is not executed until the data is actually needed which can result in more efficient and optimized queries
	
	- [IDisposable]  		=> Defines a method to release unmanaged resources.
	- [IFormattable]  		=> Defines a method to format the value of an object into a string representation.
	
	- [IEquatable<T>] 		=> Provides a method for comparing the equality of objects of the same type.
	- [IConvertible]  		=> Defines methods for converting an object to another type.
	- [ICloneable]  		=> Defines a method to create a shallow copy of an object.
	- [INotifyPropertyChanged]  	=> Defines an event for notifying clients when a property value changes.
	- [IAsyncResult]  		=> Represents the status of an asynchronous operation.
	- [IList<T>]  		=> Represents a list of objects that can be individually accessed by index.
	- [ICollection<T>]  	=> Defines methods for manipulating generic collections.
	- [IDictionary<TKey, TValue>] => Represents a generic collection of key/value pairs.
	- [IComparable<T>]  	=> Defines a method to compare an object with another object of the same type.
	- [IEqualityComparer<T>] 	=> Defines methods for comparing equality of objects of a specific type.
	- [IEquatable<T>]  		=> Provides a method for comparing the equality of objects of the same type.
	
-------------------------------------------------- [ Indexer ] --------------------------------------------------
	
	- An indexer in C# allows access to elements within this class using array-like syntax. 
	- For instance, if we have a class 'Person' and another class 'PList' containing an array of persons ('_plist'), 
	- we can access this array using the indexer. 
	- The indexer is similar to a property, but it permits indexing the class by adding square brackets '[]' to the instance name.
	       
-------------------------------------------------- [Generics] --------------------------------------------------
	- Writing a code that can work with any data type.
	- We can use Generic method in non-generic class
	- [Generic Class & Method]
		//Generic Class
		public Class GenericClass<T>
		{
			private T genericField;
			public GenericClass(T vlaue){
				GenericField = value;
			}
			//Generic Method
			public T GetValue(){
				return genericField;
			}
		}
		Genericclass<int> data = new GenericClass<int>(3);
		
	- [Generic Interfaces and Delegates]
		- public interface IGenericInterface<T>{ T GetValue(); }
		- public delegate void GenericDelegate<T>(T argument) 
		
	- [Constriants]
		- Used with Generic types to specify the capabilities or characteristics that the type parameter must have 
			- where T : class				// Ensures that the type argument is a reference type (class)
			- where T : struct				// Ensures that the type argument is a value type (struct)
			- where T : new()				// Ensures that the type argument has a parameterless constructor
			- where T : myBaseClass			// Ensures that the type argument must be or derive from a specific base class 
			- where T : IMyInterface		// Ensures that the type argument implements a specific interface
			- where T : U					// Ensures that the type argument must be or derive from the type specified by U
			- where T : notnull        		// Ensures that the type argument is non-nullable reference or non-nullable value
		- Use benefits => [ Type Safety | Reusability | Avoid Reflection | Prevent Nullability | Readability and Intent ]
		- public class Employee(): Person, IWorkable, 
	
-------------------------------------------------- [Delegate] --------------------------------------------------
	- A type which represents references to methods with a particular parameter list and return type
      - Pass a function as a parameter to another function
      - Create new delegate 
            - public delegate void MyDelegate(string message)           // A Reference Type which match only the methods that returns void and take string as a parameter 
                                                                                                           // MyDelegate is a type not an instance
      - Create Instance from the delegate
            - MyDelegate print = (a) => Console.WriteLine(a);             // Create an Instance(print) from MyDelegate Delegate and                                   
	
      
	- public delegate void MyDelegate(string message);	            // Delegate Creation, Assignable with methods void return type and takes string as a parameter 
	- public class MyClass{                                                                   
		public void MyMethod(string message){				      // We will assign the reference of that method to a variable of MyDelegate Type
			Console.WriteLine(message);
		}
	}
	- MyClass obj = new MyClass();								// Create Instance from the class MyClass to use Its method
	- MyDelegate d = obj.MyMethod;								// Assign the reference of the method to the newly created 
	// now I can pass it to a function or invoke it 
	
	- [ Multicasting ]
		- Delegates support multicastin, which means you can combine multiple methods into a single delegate
		d += obj.someOtherMethod
		d();
		
	[ Delegates Built-In ]
	
		- [ Func ] 
			- Represents a function that returns value and takes values		T1 <= T2, T3, ...
			- Func<int, int, int> add = (a,b) => a+b;	int result = add(3,5);
			
		- [ Action ]
			- Represents a method returns void and takes parameters		void <= T1, T2, ...
			- Action<string,string> print = (a,b) => Console.WriteLine(a+b);
			
		- [ Predicate ]
			- Represents a method return boolean and takes parameters		bool <= T1
			- Predicate<int> isbigger = (a) => a <= 6;	isbigger(3);		// Takes only one argument
                  
          [Anonymous delegate]
                    - A reference who have no name its reference not stored in the stack
                    - prin(delegate (int num) {return num>5})       // one use only, when we need a function just for one time, we don't create it
                    - Anonymous is not a better use instead we use Lambda Expression
                    - print(delegate (int num) { return num>5 })                   =>                  print(num => num > 5)
			
-------------------------------------------------- [ Event ] --------------------------------------------------
	- [ Observer design Pattern ]
                    - Simulating the Event Concept with that
                    
		- Publisher (Subject)
			- This is the entity that holds the information, notifies observers(listeners) about changes [WebSite, News]
		
		- Listeners (Observer)
			- These are the entities interested in being notified when the publisher changes [Users]
		
		- Subscription
			- This is the mechanism that connects the publisher and the listeners
          
          - There are issues using delegates
                    - assign delegate to null remove all the methods 
                    - any one can call it and it must be public so let the listeners subscibe
                    - Listener can assign more that one method
                    
          - To solve these 
                    - we have to disallow the listener to control the publisher => we use 'event' keyword
                    - by using event we can only use -= and +=. We can't use = so we can't assign null to it
          
          - [ Event Accessor ]
		- [ add ]		=> 	myEvent += value;
		- [ remove ]	=> 	myEvent -= value;
		-  public event EventHandler MyEvent			// EventHandler is a Delegate 
		   {
		       add { _myEvent += value; }
		       remove { _myEvent -= value; }
		   }
		   
-------------------------------------------------- [ Yield Return ] --------------------------------------------------
	
	- Is used in an iterator block to produce a sequence of avlue lazily
	- Iterator blocks are methods or properties that contain one or more Yield statements
	
	static IEnumerable<int> GenerateNumbers(){
		for (int i = 1; i<= 5; i++)
		{
			yield return i;		// multiple return executed by iterating using for each to that function
		}
	}
	IEnumerable<int> list = GenerateNumbers();	// The iterator method is called but it doesn't execute the entire method at once
	- the method starts executing until it reaches the yield retun statement 
	- the value specified after yield return is produced to the calling code 
	- the method is paused and the control returns to the calling code with the produced value 
	- the next time the iterator method is called, it resumes execution from where it left off continuing until the next yield retun or the end of the method
	- this lazy evaluation allows you to efficiently work with large seuences of data without loading all the data into memory at once

-------------------------------------------------- [ IQueryable & IEnumerable ] --------------------------------------------------
	
	// GetPeople returns list of Person objects

	+------------------------------------------------------------------------------------------+
	|// in [IEnumerable] the condition'x.age < 30' will be executed in the client side         |
	|// means that it will retrieve the data here then execute the condition                   |
	|IEnumerable<Person> enumerable = repository.GetPeopleIEnumerable().Where(x => x.Age < 30);|
	|------------------------------------------------------------------------------------------|
	|// In [IQueryable] the condition 'x.age < 30' will be executed in the server side  	 |
	|// means that it will execute the condition on server before getting the data here        |
          |IQueryable<Person>  queryable  = repository.GetPeopleIQueryable().Where (x => x.Age < 30);|
	+------------------------------------------------------------------------------------------+
	
	- enumerable and queryable will store the expression tree and will be defferred until we iterate over it or 
	- explicitly trigger the the execution by calling these methods [ .ToList() | .ToArray ]

-------------------------------------------------- [ Extension Method ] --------------------------------------------------
	- A feature in C# that allows you to add new methods to existing types without modifying them
	- Are defined in static classes and are marked with 'this' keyword before the first parameter, indicating the type that the method extends
		public static class PersonExtension{			// Rule#1 Class Must be static because it is a functionality class
			public static void Show(this Person data){	// Rule#2 Function Must be static to use it directly
								// Rule#3 First Parameter must start with 'this' then the [Class Name]
				Console.WriteLine(data.Name);
			}
		}
		// In Program 
		Person person = new Person(0, "Abdulrahman");
		       person.Show();	// Use the extension method

-------------------------------------------------- [ Async & Await ] --------------------------------------------------		       
	- Are keywords used in asynchronous programming to make it easier to work with asynchronouse code
	- Asyncronous programming is used to handle operations that may take a significant amount of time
	- Such as I/O operations or networkrequests, without blocking the main execution thread 
	
	- [async]
		- Is used to define a method as a asynchronous method
		- Asyncrhonous method can persorform work without blocking the calling thread, allowing other tasks to continue
	
	- [await]
		- Used to asynchronously wait for a task to compolete
		- It can only be used within an asynchronous method that is marked with the async keyword
		- When we use 'await' with a task the control returns to the calling method until the awaited task completes.
		- This allows theapplication to remain responsive while the asynchronous operation is in progress
		       
-------------------------------------------------- [ LinQ ] --------------------------------------------------
	
	- [ Language Integrated Query ] --------------------------------------------------
		- Came after ADO, but ADO more speed than LinQ, Used in Banks
		- We can deal with Two Primary Syntax [ Method Syntax ] & [ Query Syntax ]	// Built-in Extension Methods
		- LinQ is designed to provide a unified way of querying different type of data sources using a consistent syntax
		- It enables developers to write qureies directly in their programming language instead of using SQL or other query language seprately
	
	- [ LinQ Types ] --------------------------------------------------	
		
		1- [ LinQ to Object ] 
			-- Data Source => [ Memory Collections ]
			-- Most Common Type of LinQ query
			-- It allow you to Query in memory collections [ Arrays, List, Dictionaries ] with the LinQ operators
			-- @ var nums = new List<int> {1,2,3,4,5,6}; @ var q = nums.Where(n => n < 3);	// 
			-- then we use foreach to use it
			-- Use Case: In-memory data manipulation

		2- [ LinQ to XML ] 
			-- Data Source => [ XML Data ]
			-- Manipulate XML data using [XElement] & [XDocument] Classes
			-- we can perform operations like filtering, projecting and sorting 
			-- @ XDocument xmlDoc = XDocument.Load("fileName.xml");	
			-- @ var q = from element in xmlDoc.Descendants("Person") where (string)element.Attribute("gender") == "male" select element;
			-- Use Case: Manipulating XML data

		3- [ LinQ to SQL ]	// Not Used any more, why shoule I work with SQL Only 
			-- Data Source => [ SQL Database ] 
			-- Create LinQ Queries that translate into SQL Queries
			-- Providing strongly-typed approach to database access
			-- @ var db = new DataContext("connectionString");
			-- @ q = from customer in db.Customers where custromer.City == "NewYork" select customer;
			-- Use Case: Strongly-typed approach to database access

		4- [ LinQ to Entity ] 
			-- Similar to LinQ to SQL
			-- query databases using Entity Framework
			-- A more versatile and feature-rich ORM (Object-Relational Mapping) Framework
			-- @ using (var context = new MyDbContext())
			-- @ {var query = from product in context.Products where product.Category == "Electronics" select product;}
			-- Use Case: Similar to LinQ to SQL but more versatile and feature-rich

		5- [ LinQ to DataSet ]	// ef	
			-- Data Source => [ ADO.NET DataSet ]	
			-- which is a collection of zero or more tables represented by DataTable objects
			-- @ var dataSet = new DataSet();
			-- @ dataTable = dataSet.Tables["TableName"];
			-- @ var q = from row in dataTabel.AsEnumerable() where (int)row["Age"] > 30 select row;
			-- Use Case: Disconnected data, data retrieved from database and stored in the memory

		6- [ LinQ to Objects with parallelism ]
			-- Data Source => [ Memory Collections ] 
			-- Use PLinQ to perform LinQ Queries on in-memory collections in parallel
			-- which takes advantage of multi-coreprocessors to speed up query execution
			-- @ var nums = Enumerable.Range(1,100000);
			-- @ var q = numbers.AsParallel().Where(n=> n % 2 == 0);
			-- Use Case: Performing LinQ queries in-memory collections in parallel to take advantage of multi-core processors
	
	- [Syntax] --------------------------------------------------
		- [ Method Syntax ]
			- We use Extension methods provided by the System.LinQ ( Which designed to chained together )
			- Fluent Interface 		// Offers a more fluent and method-chaining approach
			- Lambda Expressions	// We use it for defining the Criteria for filtering, Projecting, ordering and other query operations
			- IQuerable<object> q = collection.Where(n=> n< 2).OrderBy(n=> n.Name).Select(n=> n.Name);     
						// The Output for the Where is input for the next chain
						// We Could use anonymous object to return multiple value
		- [ Query Syntax ]
			- SQL-like Syntax, we use SQL Queries
			- More preferred for comples queries
			- Compiler Translation // Under the hood, the C# compiler translates query expressions into method syntax, so the two styles are are equivalent
			- var q = from n in collection where n < 2 order by n.Name select n.Name;
	
	- [ LinQ Providers ] --------------------------------------------------
		- LinQ relies on providers to translate the LinQ queries into a format that the underlying data source can unerstand
		- Providers exist for various data sources such as LinQ to SQL for relational databases and LinQ to XML for XML
	
	- [ Standard Query Operators ] --------------------------------------------------

		1- [ Projection Operators ]
			- [ Where ]           	Filters elements based on a specified condition
			- [ OfType ]          	Filters elements of a specific type from a collection
	
		2- [ Transformation Operators ]	
			- [ Select ]          	Projects each element into a new form or type
			- [ SelectMany ]      	Projects each element of a collection to an IEnumerable and flattens the resulting sequence into one sequence
	
		3- [ Sorting Operators ]	
			- [ OrderBy ]         	Sorts elements in ascending order based on a key
			- [ OrderByDescending]	Sorts elements in descending order based on a key
			- [ ThenBy ]          	Performs a secondary sort on elements that have the same key
			- [ ThenByDescending ]	Performs a secondary descending sort on elements that have the same key
	
		4- [ Aggregation Operators ]		// All Data loaded to calculate it					
			- [ Count ]           	Returns the number of elements in a collection
			- [ Sum ]             	Computes the sum of numeric elements in a collection
			- [ Average ]         	Computes the average of numeric elements in a collection
			- [ Min ]             	Returns the minimum element in a collection
			- [ Max ]             	Returns the maximum element in a collection
			- [ Aggregate ]       	Applies an accumulator function to the elements in a collection
	
		5- [ Quantifier Operators ]	
			- [ Any ]             	Determines if any elements in a collection satisfy a specified condition
			- [ All ]             	Determines if all elements in a collection satisfy a specified condition
	
		6- [ Element Operators ]	
			- [ First ]           	Returns the first element that satisfies a specified condition
			- [ FirstOrDefault ]  	Returns the first element that satisfies a specified condition or a default value if no elements match
			- [ Single ]          	Returns the only element that satisfies a specified condition
			- [ SingleOrDefault ] 	Returns the only element that satisfies a specified condition or a default value if no elements match
	
		7- [ Set Operators ]	
			- [ Distinct ]        	Returns distinct elements from a collection
			- [ Union ]           	Returns the union of two collections
			- [ Intersect ]       	Returns the intersection of two collections
			- [ Except ]          	Returns elements that are in the first collection but not in the second collection
	
		8- [ Partitioning Operators ]	
			- [ Take ]            	Returns a specified number of elements from the start of a collection
			- [ Skip ]            	Bypasses a specified number of elements from the start of a collection
			- [ TakeWhile ]       	Returns elements from a collection as long as a specified condition is true
			- [ SkipWhile ]       	Bypasses elements from a collection as long as a specified condition is true

	- [ LinQ to Objects ] --------------------------------------------------
		- LinQ can be used with any collection that implements the IEnumerable<T> or IQueryable<T>
		- It provides a way to query in-memory collections like arrays, list, dictionaries, etc
		
	- [ LinQ to SQL & Entities ] --------------------------------------------------
		- LinQ can be used to query databases using LinQ to SQL or LinQ to Entities
		- LinQ to SQL is used for querying SQL Server databases
		- LinQ to Entities is used for querying Entity Framework data models

	- [ Deferred Execution ] --------------------------------------------------
		- LinQ Queries are lazily executed, meaning that the query is not executed until the result is actually needed
			- IEnumerable<Person> list = plist.list;				// Eager Execution, no LinQ Query used 			
			- IEnumerable<Person> list = plist.list.Where(person => person.age < 25);	// Deferred Execution, LinQ Query used, list will store the expression tree and the query will be executed when iterate over it 
			- IQueryable<Person>  list = plist.list.AsQueryable().Where(p=>p.age<25);	// Deferred Execution, the filtering will done in the server side 
		- This allows for more efficient querying, especially when dealing with large datasets
	
	- [ Anonymous Types ] --------------------------------------------------
		- LinQ often makes use of anonymous types to project the result of a query into a new type on the fly
			- var result = from item in collection select new {item.Name, item.Property};	
				// 'select' part is used for project the data
				// 'new' is used to create new instance of an anonymous object to project it
	
	- [ Lambda Exressions ] --------------------------------------------------
		- Used in LinQ to define inline functions for filtering, ordering, and projecting
			- var query = collection.Where(item=> itme.Property > 10).OrderBy(item => item.Name);
		
	- [ Integration with Language Features ] --------------------------------------------------
		- LinQ integrates seamlessly with other language  features such as lambda expressions, extension methods, and anonymous types
	
	- [ Error Handling ] --------------------------------------------------
		- LinQ provides a concise and readable way to handle errors in queries using the try-catch block
			try{
				var result = from item in collection select item.Property / item.Divisor;
			}catch (DivisionByZeroException ex){
				// Handl the exception
			}

-------------------------------------------------- [ Dependency Injection ] --------------------------------------------------			
	- Is a design pattern and a technique in software development where the components of a system are provided with their dependencies rather that creating them internally
	- Instead of a component creating its dependencies, the dependencies are "Injected" into the component from the outside
	- Types of injection are
		- Constructor Injection
		- Method Injection
		- Property Injection     

-------------------------------------------------- [ Entity Framework Core ] --------------------------------------------------
	- Entity Framework Core (EF Core)
			- Uses an Entity Data Model to represent the conceptual model of the data
			- This Models Include Entities, represents tables in the database, associations (representing relationships between entities) and mapping
			- This is the version of Entity Framework designed to work with .NET Core
		
		- Code-First / Model-First approach
			- [Code-First]
				Define C# classes; EF Core generates the database.
			- For Creating a new project Code-First 
			      - install entity framework using nuget package manger [ Install-Package EntityFramework + ENTER ]
			      - Define my model classes create classes properties and define constrains priary keys and so on 
			      - Create a DbContext that inherit from the DbContext and have DbSet for each of my model classes
			      - add a connection string specifying the database server, initial catalog and other server details also the name of the connection 
			      - don't forget to write Database.CreateIfNotExist & Database.SetInitializer in the constuctor of the class that inherits from the DbContext


			- [Model-First]
				- Design the database schema; EF Core generates C# classes.
				
		- DbContext
			- Represents a database session, includes DbSet<T> for entities.
			
		- Entity Types
			- Classes representing database tables, with properties mapping to columns.
		
		- Configuration
			- Classes representing database tables, with properties mapping to columns.
		
		- LinQ Queries
			- Use LINQ for complex queries against entity types.
			
		- Database Migrations
			- EF Core Includes a migration system that enables you to evolve the database schema as your application evelves
			- Migration can be generated and applied to update the database
		
		- Database Providers
			- Supports various database providres (SQL Server, SQLite, ...)
			
		- Async Operations
			- Supports asynchronous query and save operations for scalabitily
			
		- Dependency Injection
			- Integrated with .NET Core's dependency injection system
			
		- Logging and Interception
			- Provides logging for debugging, allows interception of database operations
	
	- [ Code First Approach ]
		- Make sure You installed these packages 		(Package)
			- Microsoft.EntityFrameworkCore
			- Microsoft.EntityFrameworkCore.Tools
			- Microsoft.EntityFrameworkCore.SqlServer
			- Microsoft.EntityFrameworkCore.Design
		
		- Define your models and the relation between each entity	(Models)
		
		- Create DbContext
			- Create a Class and Inherit from DbContext	(Data)
			- Define Ctor [defualt] & [DbContextOptions<> options]
			- Define your entities as Dbset Properites
			- Configure Database provider and Connection string Using OnConfiguring Method
				- optionsBuilder.UseSqlServer("ConnectionString");	// Don't Use the connection String here directly
					- UseSqlServer 	=> Provider
					- ConnectionString	=> "server=.;database=NameDatabase;trusted_connection=true;TrustServerCertificate=True;" 
		
		- Migration
			- Add-Migration [MigrationName]         // Create Migration
			- Update-Database			// To Create Database

		- Create Instance(Connection To Database) 
			- var context = new SchoolDbContext();
			- Implicitly Opened and Closed when reading Data
			
	- [Navigation&Shadow Properties]
		- [Shadow Property]
			- A proprety that is not defined in the entity class but is implicitly created by EF to be used for various Purposes
			- Such as Tracking changes, Storing additional information. Unlike regular properties, shadow properties are not exposed in the entity class
			- The existance is known only to EF.
		
		-[ Navigation Property ]
			- A property on an entity that represents a relationship to another entity. 
			- It allows you to navigate from one entity to another using the defined relationship
			- Reference navigation property (one-to-***)	=> public Customer Customer {get;set;}
			- Collection Navigation Property (many-to-***)	=> public ICollection<Post> Posts{get;set;}
			- [Related Keywords]
				- ForeignKey Attribute	[ForeignKey("CustomerId")]
				- InverseProperty Attribute	[InverseProperty("MainCategory")]
				- Include() method		Used to specify related data to be included in the query results when retrieving data from the database 
					- Helps in Eagrly loading the navigation properties to avoid the N+1 query problem
				- [Required] | [StringLength()] | [Column("StudentName", TypeName= "nvarchar(100)")] | [Table("Students")] | [NoMapped]
				- [ConcurrencyCheck]	 

			
	- [virtual & .Include() & .Load()]
		- using 'virtual' keyword => EF create a proxy class At runtime, which enables features such as lazy loading and change tracking
		- Lazy loading means that related entities are not loaded from the database until you access the navigation property
		- If we didn't use 'virtual' so we can use '.Include()' the property to eager loading the related entities
		- .Include() used for Eager Loading, as part of the LinQ query 
			- var studentsWithCourses = context.Students.Include(s => s.Courses).ToList();
		- .Load() used for explicit loading of related entities after the main entity has been retrieved from the database
			-var student =context.Entry(student).Collection(s => s.Courses).Load();
			
	[Lazy Loading]
		- a design pattern and a technique used to defer the loading of an object until it is actually needed       
		- improve performance and resource effciency by loading data or objects on-demand rather than loading everything upfornt.
		- [Deferred Initialization] we defer the initialization until the property is accessed for the first time 
		- [Loading On Demand] when a client code accesses the property, it checks whether the data or resource has already been loaded
		- good dealing with performance bottlenecks to avoid loading data on that moment
		@
		public class Customer
		{
		private List<Order> orders;
		public List<Order> Orders{get{if (orders==null)orders=LoadOrders();}}
		}
	  
	- [ Deffered Execution ]
		- have the same concept like in Lazy Loading but it's associated with LINQ
		- it refers to the practice of postponing the execution of a query or operation on a collection until the  results are actually needed 
		- 
		
	- [ Lazy Loading Proxy ]
		- marking a navigation property with virtual keyword in Entity framework => Generates a [Dynamic Proxy Class] at runtime for the entity class
		- used to intercept property access and load related data on-demand ( Lazy Loading )
		- without using virtual keyword, Lazy Loading won't work as expected instead to explicitly load data using methods like .Include(), .Load()
		- by making the navigation property 'virtual' we allow entity framework to create the necessary infrastructure to enable lazy loading for the property
		
	- [ N + 1 Proeblem ]
		- A common performance problem that can occur in ORM Frameworks like EF.
		- It arises when an ORM fetches a collection of entities along with their related entities in a separate query for each original entity
		- N => Represents the number of entities you initially retrieve
		- 1 => Represents the additional query executed for each of the N entitie to fetch related data
			- if We have 3 Authors each one have his books
				- The main query will retrieve the list of Authors which represents the (1)
				- when access theri books it will execute N of queries, in this case we have 3 Authors 
				- So each Author will have one qeury to get his books so we have 3 Queries which represents the (N)
				
	- [Data Seeding]
		- Seeding refers to the process of populating a database with initial data during the application's database initialization.
		- This is commonly done to provide a set of predefined data that the application relies on when it start running, ensuring that the database is in a consistent and usable state
		
		- Seeding Ways
			- Fluent API OnModelCreating method
			- Migrations using migrationBuilder.Insert() | migrationBuilder.Sql()
			- Separated Configuration Classes
			- Configure method Startup file
			- Custom Initializer IDbContextInitializer<TContext>
	
-------------------------------------------------- [ EF Fluent API ] --------------------------------------------------
	- Are methods that allws us to configure and customize the tentity model and its mapping to the underlying databse 
	- It provides a more programmatic and code-centric way to define the database schema and mappings as an alternative to using data annotations or default conventions
	
	- [Separation of Configuration from Classes]
		- With Fluent API, Configuration is separated fro mthe entity classes
		- This Scnarios where you want to keep your entity classes clean and free from attributes or annotations related to database
	- [Extensibility]
		- Provides a rich set of methods for configuring various aspects of the model and it's highly extensible
		- We can create our own conventions or configuration methods to suit specific requirements 
	
	- [Entity configuration]
		- We can use Fluent API to confiure various aspects of an entity such as [ Primary key | Indexes | Column Names | Data Types | and more ]
		- modelBuilder.Entity<user>()
			.HasKey(u=> u.UserId);
	
	- [Releationship Configuration]
		- Fluent API is Particularly Configuring relationships between entities
		- Specifying the foreign key properties and defining the cascade behavior
		- modelBuilder.Entity<order>()
			.HasOne(o=> o.Customer)
			.WithMany(c=> c.Orders)
			.HasForeignKey(o=> o.CustomerId)
			.OnDelete(DeleteBehavior.Cascade);
			
	- [Table Mapping]
		- We can use Fluent API to specify the table name, schema, and othe details for the mapped tables
		- modelBuilder.Entity<User>()
			.ToTable("AppUsers", "dbo");
		
	- [Complex Types]
		- modelBuilder.ComplexType<Address>();
	
	- [Query Types]
		- modelBuilder.Query<SomeQueryType>().ToView("Someview");
	
	- [Index Configuration]
		- Fluent API can be used to configure indexes on columns
		- modelBuilder.Entity<Product>()
			.HasIndex(p=> p.ProductCode)
			.IsUnique();
	- [Configuring Conventions]
		- Configures custom conventions applying to multiple entities
		- modelBuilder.Conventions.Add(new MyCustomCenventions());
	
	- [Fluent API Methods]
		- modelBuilder.
			- Entity<YourrEntity>()
			- HasKey(e=>e.id)
			- Property()
			- HasOne() | HasMany() | WithMany()
			- HasForeignKey()
			- ToTable()
			- HasIndex()
			- HasDisciminator<string>("Discriminator")
			- Ignore()
			- OwnsOne() | OwnsMany()
		
	modelBuilder.Entity<StudentCourse>().HasKey(sc=> new {sc.StrudentId, sc.CourseId});
	modelBuilder.Entity<StudentCourse>().HasOne(sc=>sc.Student).WithMany(s=>s.StudentCourses).HasForeignKey(sc=> sc.StudentId);
	modelBuilder.Entity<StudentCourse>().HasOne(sc=>sc.Course).WithMany(c=>c.StudentCourses).HasForeignKey(sc=>sc.CourseId);
                 
			
-------------------------------------------------- [ Attributes ] --------------------------------------------------
	- Are a powerful feature that allows you to add metadata to your code 
	- Metadata, in this context, is information about the code that is not part of the actual program logic 
	- But provides additional information for tools, compilers, or runtime environments
	- Attributes are typically used for a variety of purposes, including code documentation, code analysis, and runtime behavior customization
	
	- [Syntax]
		- Attributes are declared using square brackets '[]' placed before the target element in the code
		- The target can be [assembly, module, type, method, parameter, field, property, event, return value]
		
	- [Attributes Types]
		- System Attributes
			[CLSCompliant(true)] | [STAThread] | [Serializable]

		- Security Attributes
			[PrincipalPermission(SecurityAction.Demand, Role = "Admin")] | [SecurityCritical] | [SuppressUnmanagedCodeSecurity]

		- Code Analysis Attributes
			[CodeAnalysis.SuppressMessage("Category", "RuleId")] | [CodeAnalysis.ExcludeFromCodeCoverage] | [CodeAnalysis.SuppressWarnings("WarningCode")]

		- Testing Attributes
			[TestMethod] | [Fact] | [Test]

		- Web API Attributes
			[Route("api/users")] | [HttpGet] | [FromBody]

		- ASP.NET MVC Attributes
			[Authorize] | [HttpPost] | [ValidateAntiForgeryToken]

		- Entity Framework Attributes
			[Key] | [Column("ColumnName")] | [ForeignKey("ForeignKeyProperty")]

		- XAML Attributes
			[DisplayName("Name")] | [Category("Category")] | [Description("Description")]

		- Custom Attributes
			[CustomLog("Log Message")] | [MyCustom("Custom Value")] | [SpecialHandling("Handle this case")]

			
	- [ Data Annotation ] 
		- Validation Attributes
			- [Required] | [StringLength(50)] | [Range(18, 99)] 
		- Display Attributes
			- [Display(Name = "Full Name")] | [DisplayFormat(DataFormatString = "{0:C}")] | [DisplayName("Email Address")] 
		- Concurrency Check Attributes
			- [ConcurrencyCheck] | [Timestamp] | [DatabaseGenerated(DatabaseGeneratedOption.Identity)]

----------------------------------- [ Lower/Higher Control/Abstration ] -------------------------------
	- [Abstraction]
		- Higher-Level absraction
			- It means that the user interacts with a simplified interface that hides many details
			- The user Doesn't need to understand or deal with the lower-level complexities directly
		- Lower-Level abstraction
			- Provides more details and direct view of the unerlying system
			- User has to deal with more specifics and has a greater understanding of the inner workings
			
	- [Level of Control]
		- Higher-Level of Control
			- The programmer has more direct influence over the fine-Grained  details of the system
			- Means more flexibility but also require more responsibility for managing those details
			
		- Lower-Level of Control
			- Means that certain aspects of the system are managed automatically or abstracted away
			- Reducing the need for the programmer to micromangge  every detail
			- This can make programmin easier but might sacrifice some flexibility
	
	- [Thread]
		- Lower-Level abstraction, Higher Level of control
			- threads provide a relatively low-level abstraction of concurrent execution
			- When we work with threads, we have more direct control over the execution flow, synchronization and communication between therads
			- This also means more responsiblity for managing these details 
	
	- [Task]
		- Higher-Level Abstraction, Lower-Level of Control
			- Provide a higherLevel abstraction that allowsdevelopers to express concurrency in a more straightforward manner
			- This often result in less control over low-level details but can lead to more readable and maintainable code 
			
&&&concurrecny, thread, task, process, deadlock, parallelism, synchronization, concurrency control, asynchronous programming

------------------------------------- [ ASP.NET Core Identity ] ----------------------------------------
	- Install package Microsoft.AspNetCore.Identity.EntityFrameworkCore
	- Make the ApplicationDbContext inherit from IdentityDbContext instead of inheriting from the DbContext
	
	- [Modify Tables Names and Ignore Columns using fluent api] 
		- builder.Entity<IdentityUser>().ToTable("Users").Ignore(u=> u.PhonNumberConfirmed);
		- builder.Entity<IdentityRole>().ToTable("Roles");
		- builder.Entity<IdentityUserRole<string>>().ToTable("UserRoles");
		- and so on for Users, Roles, UserRoles, UserClaims, UserLogins, RoleClaims, UserTokens
		
	- [Add Extra Properties for the Identity tables]
		- Create a class and inherit from the table that you want to extent like 
			- public class User : IdentityUser{
				// Add properties
			}
		- In the application context we have to use generic type from the IdenttiyDbContext
			- public class ApplicationDbContext : IdentityDbContext<User>{}	// Note that We added the Classes that Are extended for each tables
		
		- In case we extended more that one table we add them all like 
			- public class ApplicationDbContext : IdentityDbContext<User, UserRoles, ...> {}
	
	- [Methods for Each Class & methods in Identity]
		- UserManger<TUser>		=> [CreateAsync | DeleteAsync | FindByIdAsync | UpdateAsync | GetRolesAsync]
		- SignInManger<TUser>	=> [PasswordSignInAsync | SignInAsync | SignOutAsync | TwoFactorSignInAsync]
		- RoleManger<TRole>		=> [CreateAsync | DeleteAsync | FindByIdAsync | FindByNameAsync | UpdateAsync | GetUsersInRoleAsync]
		- ClaimsPrincipal		=> [IsInRole | HasClaim]
		- PasswordHasher<TUser>	=> [HashPassword | VerifyHashedPassword]
		- IdentityResultClass
		- TokenProviders		=> [GenerateEmailConfirmationTokenAsync | GeneratePasswordResetTokenAsync ...]
		- IdentityOptions		
		- UserClaims & UserProperties => [AddClaimAsync | RemoveClaimAsync | ...]
	
	- [ASP.NET Core Identity Tables]
		- [Users]		=> User information like Id, username, confirmation flag and so on
		- [Roles]		=> Role information, roles are used to group users and apply authorization based on role
		- [UserRoles]	=> A linking table that establishes a many to many relationship between users and roles, User Id and Role Id
		- [UserLogins]	=> Used to store external login information, include user Id, login provider, provider key, and display name
		- [UserClaims]	=> Stores user claims, Storing additional user information or authorization data
		- [UserTokens]	=> Used to store tokens (Security tokens, password reset tokens), it includes (User Id, Login provider, and name)
		- [RoleClaims]	=> Stores claims associated with roles
		- [UserTokens]	=> This table is used to store tokens associated with a user
	
	- Create IAccountMangerService & AccountMangerService and Inject it in the controller 
	- Install Package AutoMapper dependency injection
	
	- Register New User
		
		
		-[Create User]
		
		     - Create Credential DTO for Receive the registeration data from the user  
		     - Create User Instance and Assign the data received form the Credential DTO
		     - _userManger.CreateAsync(UserInstnaace, PasswordFromCredentialsReceived);	Returns IdentityResult which indicate the state of the Creations
		
		- [Assign Role]
		     - Check for Roles, Create if not exist and assign it to the Created User
		     - Assign Role to the created account also check at first if the role exist if not Create new role and then assign it 
		     - UserRole.Concurrencytsamp = Guid.NewGuid().ToString();		// Adding New 128-bit value => GIUD Structure  
		     - _roleManger.RoleExistsAync("") | _roleManger.Createsync(IdentityRole UserRole) | _userManger.AddToRoleAsync(NewUser, "User")
		
		- [Assign Claims]
		     - Create Claims to the User => List<Claim>{ new Claim(ClaimTypes.NameIdentifier, NewUser.Id.ToString()), ...}
		     - _userManger.AddClaimsAsync(NewUser, claims)
		     
	- Login 
		- [Verify Email]
		- [Check Lockout]
		- [Verify Password]
		- 




